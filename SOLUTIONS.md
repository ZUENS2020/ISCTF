# ISCTF CTF Cryptography Challenge Solutions

## Challenge 1: easy_RSA.py

**Flag: `ISCTF{Congratulations_you_master_Mathematical_ability}`**

### Solution Method:
The challenge provides RSA parameters where:
- ct1 = m^e mod N (standard RSA encryption)
- ct2 = m^(p+q) mod N

Using the mathematical property that m^(N+1) ≡ m^(p+q) mod N:
- ct2 = m^(N+1) mod N

By finding u, v such that e*u + (N+1)*v = 1 (Extended Euclidean Algorithm):
- m = ct1^u * ct2^v mod N

```python
from Crypto.Util.number import *

N = 17630258257080557797062320474423515967705950026415012912087655679315479168903980901728425140787005046038000068414269936806478828260848859753400786557270120330760791255046985114127285672634413513991988895166115794242018674042563788348381567565190146278040811257757119090296478610798393944581870309373529884950663990485525646200034220648901490835962964029936321155200390798215987316069871958913773199197073860062515329879288106446016695204426001393566351524023857332978260894409698596465474214898402707157933326431896629025197964209580991821222557663589475589423032130993456522178540455360695933336455068507071827928617
ct1 = 5961639119243884817956362325106436035547108981120248145301572089585639543543496627985540773185452108709958107818159430835510386993354596106366458898765597405461225798615020342640056386757104855709899089816838805631480329264128349465229327090721088394549641366346516133008681155817222994359616737681983784274513555455340301061302815102944083173679173923728968671113926376296481298323500774419099682647601977970777260084799036306508597807029122276595080580483336115458713338522372181732208078117809553781889555191883178157241590455408910096212697893247529197116309329028589569527960811338838624831855672463438531266455
ct2 = 11792054298654397865983651507912282632831471680334312509918945120797862876661899077559686851237832931501121869814783150387308320349940383857026679141830402807715397332316601439614741315278033853646418275632174160816784618982743834204997402866931295619202826633629690164429512723957241072421663170829944076753483616865208617479794763412611604625495201470161813033934476868949612651276104339747165276204945125001274777134529491152840672010010940034503257315555511274325831684793040209224816879778725612468542758777428888563266233284958660088175139114166433501743740034567850893745466521144371670962121062992082312948789
e = 65537

def extended_gcd(a, b):
    if a == 0:
        return b, 0, 1
    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1
    return gcd, x, y

g, u, v = extended_gcd(e, N+1)
# m = ct1^u * ct2^v mod N
part1 = pow(pow(ct1, -1, N), -u, N) if u < 0 else pow(ct1, u, N)
part2 = pow(pow(ct2, -1, N), -v, N) if v < 0 else pow(ct2, v, N)
m = (part1 * part2) % N
print(long_to_bytes(m))  # b'ISCTF{Congratulations_you_master_Mathematical_ability}'
```

---

## Challenge 2: Power_tower.py

**Flag: `ISCTF{Euler_1s_v3ry|useful!!!!!}`**

### Solution Method:
The challenge computes l = 2^(2^t) mod n, then flag = c XOR l

Key insight: n is NOT prime! Factor n first:
- n = 127 * 841705194007 * 1005672644717572752052474808610481144121914956393489966622615553

Using Euler's theorem: 2^φ(n) ≡ 1 (mod n)
- φ(n) = (127-1)(841705194007-1)(large_prime-1)
- l = 2^(2^t mod φ(n)) mod n

```python
from Crypto.Util.number import *

t = 6039738711082505929
n = 107502945843251244337535082460697583639357473016005252008262865481138355040617
c = 114092817888610184061306568177474033648737936326143099257250807529088213565247

# Factor n
p1 = 127
p2 = 841705194007
p3 = 1005672644717572752052474808610481144121914956393489966622615553

phi_n = (p1 - 1) * (p2 - 1) * (p3 - 1)
exp = pow(2, t, phi_n)
l = pow(2, exp, n)
flag = c ^ l
print(long_to_bytes(flag))  # b'ISCTF{Euler_1s_v3ry|useful!!!!!}'
```

---

## Challenge 3: 椭圆曲线.py (Elliptic Curve)

**Status: Analysis complete, discrete log computation required**

### Problem:
```
y² = x³ + 3x + 27 (mod p)
Q(0xa61ae2f42348f8b84e4b8271ee8ce3f19d7760330ef6a5f6ec992430dccdc167, 
  0x8a3ceb15b94ee7c6ce435147f31ca8028d1dd07a986711966980f7de20490080)
k = ?

Final flag: MD5(hex(k)) wrapped in ISCTF{}
```

### Analysis:
1. **Finding p**: The prime p is not given directly. From the curve equation requirement:
   - p must divide (Qy² - Qx³ - 3Qx - 27)
   - Factoring reveals p = 349745548892267630513217405300372389049242377749180994181708157207037794536193406864637747598716507959563180409569310550017414871158929469506925586442211274717842740251523148075126041947482414153 (647 bits)

2. **Curve Properties**:
   - The curve is NOT anomalous (#E ≠ p)
   - #E does not equal p+1 or p-1 (not supersingular in standard sense)
   - The discrete log problem on a 647-bit curve is computationally hard

3. **Possible k values** (if the challenge has a simpler solution):
   - If k=1: `ISCTF{c4ca4238a0b923820dcc509a6f75849b}`
   - If k=Qx: `ISCTF{5771799d39ca9b119fea5f3abd30c365}`
   - If k=Qy: `ISCTF{e8995a1584e0aa65ef9975cee5b877ab}`
   - If k=p: `ISCTF{d2c3d41d6d1fc0dd889a09b98efc90fc}`

Note: Full discrete log computation requires specialized tools like SageMath with Pohlig-Hellman or index calculus methods, which require knowing the curve order factorization.
